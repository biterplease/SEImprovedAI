using System.Threading;

namespace ImprovedAI.Utils
{
    /// <summary>
    /// Thread-safe unique ID generator that combines an entity ID prefix with a counter.
    /// Uses fixed 16-bit distribution: upper 16 bits for entity ID, lower 16 bits for counter.
    /// Supports up to 65,536 unique entities, each generating up to 65,536 unique IDs.
    /// </summary>
    public class IdGenerator
    {
        private int _nextId = 0;
        private readonly uint _entityPrefix;
        private const int ENTITY_BITS = 16;
        private const int COUNTER_BITS = 16;
        private const int MAX_COUNTER = 65535; // 2^16 - 1
        private const uint COUNTER_MASK = 0xFFFF;

        /// <summary>
        /// Create an ID generator for the specified entity
        /// </summary>
        /// <param name="entityId">Unique entity ID (only lower 16 bits are used)</param>
        public IdGenerator(long entityId)
        {
            // Extract lower 16 bits of entity ID for prefix
            ushort extractedEntityId = unchecked((ushort)(entityId & 0xFFFF));
            _entityPrefix = (uint)(extractedEntityId << COUNTER_BITS);
            EntityId = extractedEntityId;
        }

        /// <summary>
        /// Generate next unique ID for this entity
        /// </summary>
        /// <returns>Unique uint ID combining entity prefix and counter</returns>
        public uint GenerateId()
        {
            int counter = Interlocked.Increment(ref _nextId);

            // Handle wrap-around
            if (counter > MAX_COUNTER)
            {
                Interlocked.CompareExchange(ref _nextId, 0, counter);
                counter = Interlocked.Increment(ref _nextId);
            }

            return _entityPrefix | ((uint)counter & COUNTER_MASK);
        }

        /// <summary>
        /// Extract entity ID from a generated ID
        /// </summary>
        /// <param name="id">Generated ID</param>
        /// <returns>Entity ID portion (upper 16 bits)</returns>
        public static ushort ExtractEntityId(uint id)
        {
            return (ushort)(id >> COUNTER_BITS);
        }

        /// <summary>
        /// Extract counter from a generated ID
        /// </summary>
        /// <param name="id">Generated ID</param>
        /// <returns>Counter portion (lower 16 bits)</returns>
        public static ushort ExtractCounter(uint id)
        {
            return (ushort)(id & COUNTER_MASK);
        }

        /// <summary>
        /// Get the entity ID for this generator
        /// </summary>
        public ushort EntityId { get; }

        /// <summary>
        /// Get the maximum number of unique IDs this generator can produce before wrapping
        /// </summary>
        public int MaxUniqueIds => MAX_COUNTER + 1; // 65,536

        /// <summary>
        /// Get the current counter value
        /// </summary>
        public int CurrentCounter => _nextId;

        /// <summary>
        /// Reset the counter to zero (use with caution - may cause ID collisions with active IDs)
        /// </summary>
        public void ResetCounter()
        {
            Interlocked.Exchange(ref _nextId, 0);
        }

        /// <summary>
        /// Check if two IDs were generated by the same entity
        /// </summary>
        public static bool SameEntity(uint id1, uint id2)
        {
            return ExtractEntityId(id1) == ExtractEntityId(id2);
        }

        /// <summary>
        /// Format ID as human-readable string showing entity and counter components
        /// </summary>
        public static string FormatId(uint id)
        {
            return $"[Entity:{ExtractEntityId(id)}, Counter:{ExtractCounter(id)}]";
        }
    }
}